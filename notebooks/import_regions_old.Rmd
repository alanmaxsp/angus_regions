---
title: "Contemporary group solutions data import"
author: "Harly Durbin"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = TRUE)
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(magrittr)
library(purrr)
library(ggplot2)
library(rlang)
library(tidylog)
library(magrittr)
library(tidylog)

source(here::here("source_functions/slice_cg_new.R"))
source(here::here("source_functions/coalesce_join.R"))

options(scipen=999)
```

# Notes & questions

* Traits in solutions file:
    + 1 == BW
    + 2 == WW
    + 3 == YW
* Effects in solutions file:
    + 1 == contemporary group solution (with mean in it? Maybe not fit separately?)
    + 2 == Breeding value
    + 3 == Maternal
    + 4 == Permanent environment


# Setup

```{r}

# renf90.dat file generated by BLUPF90 - phenotypes + renamed CG numbers + renamed ids
# converted from wide to long format
source(here::here("source_functions/growth_pheno.R"))
# 3 generation pedigree generated by BLUPF90
source(here::here("source_functions/ped.R"))
```

```{r}
ped <- pull_ped(refresh = FALSE)
```

# Subset solutions file


## Contemporary group solutions

## Animal solutions

```
awk '{if ($1 == 2 && $2 != 1 && $2 != 4) {print}}' data/raw_data/solutions > data/raw_data/ww_animal.txt
awk '{if ($1 == 3 && $2 == 2) {print}}' data/raw_data/solutions > data/raw_data/pwg_animal.txt
```

# Region key {.tabset}

* Key assigning zip codes to climate zones

## Import

```{r region_key}

region_key <-
  # Zipcode-climate zone key
  # 32,656 rows
  read_table2(
    here::here("data/raw_data/zipcode_climatezones.txt"),
    col_names = c("zip", "region"),
    col_types = c("c", "n")
  ) %>%
  # Damn it Troy
  # Regions 4 & 6 are reversed from map
  mutate(
    region =
      case_when(
        region == 4 ~ 6,
        region == 6 ~ 4,
        TRUE ~ region),
    # The way Troy wrote keys stripped leading zeroes
    # from zip codes, add them back
    zip =
      case_when(
        str_length(zip) < 5 ~ str_pad(
          zip,
          width = 5,
          side = "left",
          pad = "0"
        ),
        TRUE ~ zip
      )
  ) %>%
  # Zipcode - coordinates key
  # https://simplemaps.com/data/us-zips
  # Updated to new key 12/10 after realizing old key excluded ~2,000 zips
  left_join(
    # 33,099 rows
    read_csv(here::here("data/raw_data/uszips.csv")) %>% 
      select(
        lat,
        lng,
        zip,
        abb = state_id
      )
  ) %>%
  # Add region descriptions
  mutate(
    desc =
      case_when(
        region == 1 ~ "Desert (orange)",
        region == 2 ~ "Southeast (teal)",
        region == 3 ~ "High Plains (green)",
        region == 4 ~ "Rainforest (red)",
        region == 5 ~ "Arid Prairie (yellow)",
        region == 6 ~ "Cold Desert (grey)",
        region == 7 ~ "Forested Mountains (pink)",
        region == 8 ~ "Fescue Belt (black)",
        region == 9 ~ "Upper Midwest & Northeast (purple)"
      )
  ) %>% 
  coalesce_join(
    tibble::tribble(
        ~zip, ~abb,
     "84144",   "UT",
     "83601",   "ID",
     "95314",   "CA",
     "95250",   "CA",
     "98929",   "WA",
     "98205",   "WA",
     "19542",   "PA",
     "20307",   "DC",
     "17767",   "PA",
     "17270",   "PA",
     "45145",   "OH",
     "45418",   "OH",
     "48921",   "MI",
     "42731",   "KY",
     "42084",   "KY",
     "54934",   "WI",
     "63464",   "MO",
     "54010",   "WI",
     "64192",   "MO",
     "66019",   "KS",
     "56177",   "MN"
     ),
    by = "zip"
  )



```

## Validation

* Confirmed I fixed Troy's lack of leading zeroes

```{r}
region_key %>% 
  filter(str_detect(zip, "^0"))
```

```{r}
region_key %>% 
  filter(str_length(zip) > 5)
```

```{r}
region_key %>% 
  filter(is.na(lat)) 

```

```{r}
region_key %>% 
  visdat::vis_miss()
```


# Zip codes & weigh dates {.tabset}

* Breeder zip code for each contemporary group
* Attach regions, filter out CGs missing zip codes or that don't assign to regions

## Import

```{r ww_zip, echo= TRUE}


growth_zip <-
  # Breeder zip codes, weigh dates, and "old" CG names from Lou Ann
  # 973,175 rows
  # 12,105 distinct zip_raw
  list(here::here("data/raw_data/Wean_CG_Zip_WeighDt.txt"), here::here("data/raw_data/Year_CG_Zip_WeighDt.txt")) %>% 
  rlang::set_names("ww", "pwg") %>% 
  purrr::map_dfr(read_tsv, 
                 col_names = c("cg_old", "zip_raw", "herd_state", "weigh_date"), 
                 skip = 1, 
                 .id = "trait") %>% 
  mutate(weigh_date = lubridate::mdy(weigh_date)) %>% 
  # Foreign zips, drop
  # filter: removed 982 out of 973175 rows (<1%)
  filter(!str_detect(zip_raw, "[[:alpha:]]")) %>% 
  # Strip down to five digit zip code
  # DON'T convert from character to numeric: removes leading zeros
  # mutate: new variable 'zip' with 9899 unique values and 0% NA
  mutate(
    zip =
      case_when(
        str_detect(zip_raw, "[[:punct:]]") ~ str_extract(zip_raw, "^[[:digit:]]{5}"),
        TRUE ~ zip_raw
      )) %>% 
  # assign to a region by zip code
  # Add lat, lng, state abbreviation, region info cols
  # join by zip
  tidylog::left_join(region_key) %>% 
  # 19,303 (from 381 zip codes) that don't match up to a region: possibly PO Boxes?
  # For now, drop
  # filter: removed 19303 out of 972193 rows (2%)
  tidylog::filter(!is.na(region)) %>% 
  # For now, drop if herd state doesn't match zip code state
  # filter: removed 9646 out of 952890 rows (1%)
  tidylog::filter(herd_state == abb) %>% 
  select(-abb)

```


## Validation

* Check for multiple region assignments

```{r, eval=FALSE}
growth_zip %>% 
  group_by(trait, zip) %>% 
  filter(n_distinct(region) > 1)
```

```{r, eval = FALSE}
growth_zip %>% 
  filter(is.na(region))

```

```{r, evale = FALSE}
growth_zip %>% 
  filter(is.na(lat))
```


# RenF90 table {.tabset}

* Key: CG number prior and post re-naming, number of animals in each CG

## Import

```{r renf90, echo = TRUE}

# Key for CG names, number of animals
renf90 <-
  readr::read_table2(here::here("data/raw_data/renf90.tables"),
                   skip = 2, col_names = c("cg_old", "n_animals", "cg_new")) %>% 
  # 4 rows with all NAs except cg_new: parsing error?
  filter(!is.na(cg_old))

```

`r scales::comma(nrow(renf90))` rows in RenF90 table

## Validation

* Contemporary group "continuity": contemporary groups can only be "subset"/split across life stages. How many contemporary groups have data for more than one trait?

```{r, eval = FALSE}

renf90 %>% 
  group_by(cg_old) %>% 
  summarise(n_traits = n()) %>% 
  ungroup %>% 
  group_by(n_traits) %>% 
  summarise(n_CGs = n())
  
```

* Do any CGs have multiple "new" names?
    + I.e., resulting from splitting a CG

```{r, eval = FALSE}

renf90 %>% 
  group_by(cg_old) %>% 
  summarise(n_names = n_distinct(cg_new)) %>% 
  ungroup() %>% 
  group_by(n_names) %>% 
  summarise(n = n())

```


# Animal solutions & phenotypes {.tabset}

* Effects in solutions file:
    + 2 == Breeding value
    + 3 == Maternal
    + 4 == Permanent environment
  

```{r animal_solutions, echo = TRUE}
animal_solutions <-
  # Solutions files, separated out between ww and pwg
  list(
    here::here("data/raw_data/ww_animal.txt"),
    here::here("data/raw_data/pwg_animal.txt")
  ) %>%
  rlang::set_names("ww", "pwg") %>%
  purrr::map(read_table2,
             col_names = c("trait", "effect", "id_new", "solution")) %>%
  purrr::map(
    mutate,
    effect_key =
      case_when(effect == 2 ~ "bv_sol",
                effect == 3 ~ "mat_sol"),
    trait =
      case_when(trait == 2 ~ "ww",
                trait == 3 ~ "pwg")
  ) %>% 
  # cols: trait (ww or pwg), id_new, solution, effect_key (bv_sol or mat_sol)
  purrr::map(select, -effect) %>% 
  # pivot wider to reduce computing load
  # cols: trait (ww or pwg), id_new, bv_sol, mat_sol
  purrr::map(pivot_wider,
             names_from = effect_key,
             values_from = solution) %>% 
  # Join by trait and id_new
  # cols: trait (ww or pwg), id_new, bv_sol, mat_sol, weight, cg_new
  purrr::map(left_join, growth_pheno) %>%
  # Take out animals that got a breeding value but don't actually have a recorded weight
  purrr::map(filter, !is.na(weight)) %>% 
  # cols: trait (ww or pwg), id_new, cg_new, bv_sol, mat_sol, weight
  purrr::map(select, trait, id_new, cg_new, everything()) %>% 
  # Go back to long format
  # cols: trait (ww or pwg), id_new, cg_new, var (bv_sol, mat_sol, or weight), value
  purrr::map(pivot_longer, cols = -(trait:cg_new), names_to = "var") %>% 
  purrr::reduce(bind_rows)
```


```{r export animal_solutions, echo = TRUE}
write_rds(animal_solutions, here::here("data/derived_data/animal_solutions_old.rds"))

```

## Joined


```{r animal_regions}

animal_regions <-
  # Before joining animal solutions,
  # cols: trait, cg_old, zip_raw, herd_state, weigh_date, zip, region, lat, lng, desc, n_animals, cg_new
  growth_zip %>%
  # Purpose: match up old CG name to blupf90 renamed CG
  # Slice second occurence because ww is trait 2
  slice_cg_new(trait_var = "ww", trait_order = 2) %>%
  bind_rows(growth_zip %>%
              # Slice third occurence because pwg is trait 3
              slice_cg_new(trait_var = "pwg", trait_order = 3)) %>%
  # Purpose: add solutions from BLUPF90 output, add new IDs
  # join by cg_new, trait
  # cols: trait, cg_old, zip_raw, herd_state, weigh_date, zip, region, lat, lng, desc, n_animals, cg_new, id_new, var, value
  left_join(animal_solutions) %>%
  # Purpose: add et status & real registration number
  # cols: trait, cg_old, zip_raw, herd_state, weigh_date, zip, region, lat, lng, desc, n_animals, cg_new, id_new, var, value, full_reg, et_status
  left_join(ped %>%
              select(id_new, full_reg, et_status)) %>%
  mutate(year = lubridate::year(weigh_date)) %>%
  select(
    full_reg,
    et_status,
    trait,
    var,
    value,
    weigh_date,
    year,
    id_new,
    cg_old,
    cg_new,
    n_animals,
    region,
    desc,
    herd_state,
    zip,
    lat,
    lng
  ) %>%
  mutate(
    helper =
      case_when(
        # Remove if assigned to region 8 but not in actual fescue belt
        herd_state %in% c(
          "CA",
          "WA",
          "OR",
          "PA",
          "NY",
          "WI",
          "NJ",
          "MA",
          "MD",
          "DE",
          "MI",
          "CT",
          "RI",
          "NH",
          "NE"
        ) & region == 8 ~ "drop",
        # Remove if in region 9 but not actually in UMWNE
        herd_state %in% c("CA", "OR", "ID", "WA") &
          region == 9 ~ "drop",
        TRUE ~ "keep"
      )
  ) %>%
  filter(helper == "keep") %>%
  # compute new animals per cg after removing ET calves
  filter(et_status == FALSE) %>%
  # Make sure to group by var as well or else n_animals will be multiplied by number of effects
  group_by(cg_new, trait, var) %>%
  mutate(n_animals = n()) %>%
  ungroup() %>%
  select(-helper,-et_status) %>% 
  filter(n_animals > 1)

  
```


# Contemporary group solutions

```{r cg_solutions}
cg_solutions <-
  read_table2(
    here::here("data/raw_data/cg_sol.txt"),
    col_names = c("trait", "effect", "cg_new", "solution")
  ) %>%
  # don't need effect, they're all cg_sol
  select(-effect) %>%
  # don't need birth weight
  filter(trait != 1) %>% 
  mutate(trait =
           case_when(
             trait == 2 ~ "ww",
             trait == 3 ~ "pwg"
             ))
```


## Joined

```{r cg_regions}

cg_regions <-
  growth_zip %>% 
  # Before joining cg solutions,
  # cols: trait, cg_old, zip_raw, herd_state, weigh_date, zip, region, lat, lng, desc, n_animals, cg_new
  # Slice second occurence because ww is trait 2
  slice_cg_new(trait_var = "ww", trait_order = 2) %>% 
  bind_rows(
    growth_zip %>% 
       # Slice third occurence because pwg is trait 3
      slice_cg_new(trait_var = "pwg", trait_order = 3)
    ) %>% 
  # cols: trait, cg_old, zip_raw, herd_state, weigh_date, zip, region, lat, lng, desc, n_animals, cg_new, solution, year, var
  left_join(cg_solutions) %>% 
  mutate(year = lubridate::year(weigh_date),
         var = "cg_sol") %>% 
  select(trait, var, value = solution, weigh_date, year, cg_old, cg_new, region, desc, herd_state, zip, lat, lng) %>% 
  # Only keep CGs that weren't tossed in animal_regions, add updated n_animals column
  # Joining, by = c("trait", "cg_new")
  # right_join: removed 58178 rows and added one column (n_animals)
  right_join(
    animal_regions %>% 
      select(trait, cg_new, n_animals) %>% 
      distinct()
  )
```


# Export


```{r export animal_regions}
readr::write_rds(animal_regions, here::here("data/derived_data/animal_regions_old.rds"))
```


```{r export cg_regions}
readr::write_rds(cg_regions, here::here("data/derived_data/cg_regions_old.rds"))
```


# Commentary

Post-weaning gain and weaning weight phenotypes recorded on registered Angus cattle between 1990 and 2018 were extracted from the **[what week]** weekly growth run of the American Angus Association (AAA) National Cattle Evaluation (NCE). Phenotypes were adjusted for sex, age of dam, and age in accordance with BIF guidelines prior to entering the NCE. Breeding values and contemporary group solutions were calculated  **[more about NCE growth model]**. These breeding values and contemporary group solutions will hereafter be referred to the "NCE solutions".  
Weigh dates, breeder zip code, and herd state (state in which the phenotype was recorded) were extracted from the AAA database for all animals with a weaning weight or yearling weight recorded in the continental United States. Phenotypes were then assigned to an environmental region based on zip code. In order to ensure accurate region assignment, phenotypes were discarded if the breeder zip code did not reside in the herd state. Further, phenotypes on animals born via embryo transfer were discarded.  
While our k-means clustering environmental regions are helpful for delineating region-specific stressors, some assignments were not useful to the goals of this project. Some records assigned to region 8 (Fescue Belt) originated from locales where Kentucky-31 endophyte-infected fescue is not propagated (particularly, the western & eastern coasts and central plains). Records from these regions assigned to region 8 were dropped.  Due to sample size disparity, records assigned to regions 4 (Rainforest) and 6 (Cold Desert) were also excluded.    
The resulting dataset included `r cg_regions %>% filter(year >= 1990) %>% filter(trait == "ww") %>% summarise(n = sum(n_animals)) %>% pull(n) %>% scales::comma()` weaning weight and `r cg_regions %>% filter(year >= 1990) %>% filter(trait == "pwg") %>% summarise(n = sum(n_animals)) %>% pull(n) %>% scales::comma()` post-weaning gain measurements, stratified by region as below: 


```{r}

cg_regions %>% 
  filter(year >= 1990) %>% 
  filter(!region %in% c(4, 6)) %>% 
  group_by(trait, region, desc) %>% 
  summarise(n = sum(n_animals)) %>% 
  ungroup() %>% 
  mutate(trait = glue::glue("n_{trait}")) %>% 
  spread(trait, n) %>% 
  arrange(desc(n_ww)) %>% 
  mutate(n_ww = scales::comma(n_ww),
         n_pwg = scales::comma(n_pwg)) %>% 
  rename(Region = region,
         `Region description` = desc,
         `n PWG` = n_pwg,
         `n WW` = n_ww)

```

----

```{r}
animal_regions_full <-
  read_rds(here::here("data/derived_data/import_regions/animal_regions_full.rds")) %>% 
  filter(year >= 1990) %>% 
  filter(trait == "ww") %>% 
  filter(!region %in% c(4, 6)) %>% 
  filter(n_animals >= 5)
```

```{r}

cg_regions_full <-
  read_rds(here::here("data/derived_data/import_regions/cg_regions_full.rds")) %>% 
  select(-n_animals) %>% 
  right_join(
    animal_regions_full %>% 
      select(trait, cg_new, n_animals) %>% 
      distinct()
  )
```

```{r}
animal_regions_full %>%
  filter(var == "weight") %>% 
  summarise(mean =  measurements::conv_unit(mean(value), from = "lbs", to = "kg"),
            sd =  measurements::conv_unit(sd(value), from = "lbs", to = "kg"), 
            n = n())
```

```{r}
cg_regions_full %>% 
  group_by(region) %>% 
  summarise(records = sum(n_animals),
            cgs = n())
```

```{r}
animal_regions_full %>% 
  write_rds(here::here("data/derived_data/animal_regions_old.rds"))
```

```{r}
cg_regions_full %>% 
  write_rds(here::here("data/derived_data/cg_regions_old.rds"))
```
