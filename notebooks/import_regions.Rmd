---
title: "NCE EBV and contemporary group solutions data import & filtering"
author: "Harly Durbin"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = TRUE)
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(magrittr)
library(purrr)
library(ggplot2)
library(rlang)
library(tidylog)
library(magrittr)
library(glue)
library(tidylog)

source(here::here("source_functions/slice_cg_new.R"))
source(here::here("source_functions/coalesce_join.R"))
source(here::here("source_functions/three_gen.R"))
source(here::here("source_functions/ped.R"))

options(scipen=999)

```

# Notes & questions

* Traits in solutions file:
    + 1 == BW
    + 2 == WW
    + 3 == YW
* Effects in solutions file:
    + 1 == contemporary group solution (with mean in it? Maybe not fit separately?)
    + 2 == Breeding value
    + 3 == Maternal
    + 4 == Permanent environment

# Setup

```{r,message=FALSE}
# renf90.dat file generated by BLUPF90 - phenotypes + renamed CG numbers + renamed ids
# converted from wide to long format
source(here::here("source_functions/growth_pheno.R"))
```

```{r}
growth_pheno %<>%
  filter(trait == "ww")
```

```{r}
ped <- pull_ped(refresh = FALSE)
```

# Subset solutions file

```
awk '{if ($1 == 1 && $2 == 2) {print}}' data/raw_data/solutions > data/raw_data/bw_animal.txt
awk '{if ($1 == 2 && $2 != 1 && $2 != 4) {print}}' data/raw_data/solutions > data/raw_data/ww_animal.txt
awk '{if ($1 == 3 && $2 == 2) {print}}' data/raw_data/solutions > data/raw_data/pwg_animal.txt
```

# Region key

* Key assigning zip codes to climate zones

```{r region_key}

region_key <-
  # Zipcode-climate zone key
  # 32,656 rows
  read_table2(here::here("data/raw_data/import_regions/zipcode_climatezones.txt"),
              col_names = c("zip", "region"),
              col_types = c("c", "n")) %>%
  # Damn it Troy
  # Regions 4 & 6 are reversed from map
  mutate(region = case_when(region == 4 ~ 6,
                            region == 6 ~ 4,
                            TRUE ~ region),
         # The way Troy wrote keys stripped leading zeroes
         # from zip codes, add them back
         zip = case_when(str_length(zip) < 5 ~ str_pad(zip,
                                                       width = 5,
                                                       side = "left",
                                                       pad = "0"),
                         TRUE ~ zip)) %>%
  # Zipcode - coordinates key
  # https://simplemaps.com/data/us-zips
  # Updated to new key 12/10 after realizing old key excluded ~2,000 zips
  # 33,099 rows
  left_join(read_csv(here::here("data/raw_data/import_regions/uszips.csv")) %>% 
              select(lat,
                     lng,
                     zip,
                     abb = state_id)) %>%
  # Add region descriptions
  mutate(desc = case_when(region == 1 ~ "Desert (orange)",
                          region == 2 ~ "Southeast (teal)",
                          region == 3 ~ "High Plains (green)",
                          region == 4 ~ "Rainforest (red)",
                          region == 5 ~ "Arid Prairie (yellow)",
                          region == 6 ~ "Cold Desert (grey)",
                          region == 7 ~ "Forested Mountains (pink)",
                          region == 8 ~ "Fescue Belt (black)",
                          region == 9 ~ "Upper Midwest & Northeast (purple)")) %>% 
  # Random missing zip codes
  coalesce_join(tibble::tribble(~zip, ~abb,
                                "84144", "UT",
                                "83601", "ID",
                                "95314", "CA",
                                "95250", "CA",
                                "98929", "WA",
                                "98205", "WA",
                                "19542", "PA",
                                "20307", "DC",
                                "17767", "PA",
                                "17270", "PA",
                                "45145", "OH",
                                "45418", "OH",
                                "48921", "MI",
                                "42731", "KY",
                                "42084", "KY",
                                "54934", "WI",
                                "63464", "MO",
                                "54010", "WI",
                                "64192", "MO",
                                "66019", "KS",
                                "56177", "MN"),
                by = "zip")
```

# Zip codes & weigh dates

* Breeder zip code for each contemporary group
* Attach regions, filter out CGs missing zip codes or that don't assign to regions

```{r ww_zip, echo= TRUE}

growth_zip <-
  # Breeder zip codes, weigh dates, and "old" CG names from Lou Ann
  read_tsv(here::here("data/raw_data/import_regions/Wean_CG_Zip_WeighDt.txt"),
           col_names = c("cg_old", "zip_raw", "herd_state", "weigh_date"),
           skip = 1) %>% 
  mutate(weigh_date = lubridate::mdy(weigh_date),
         trait = "ww") %>% 
  # Foreign zips, drop
  filter(!str_detect(zip_raw, "[[:alpha:]]")) %>% 
  # Strip down to five digit zip code
  # DON'T convert from character to numeric: removes leading zeros
  # mutate: new variable 'zip' with 9899 unique values and 0% NA
  mutate(zip = case_when(str_detect(zip_raw, "[[:punct:]]") ~ str_extract(zip_raw, "^[[:digit:]]{5}"),
                         TRUE ~ zip_raw)) %>% 
  # assign to a region by zip code
  # Add lat, lng, state abbreviation, region info cols
  # join by zip
  tidylog::left_join(region_key) %>% 
  # Handful that don't match up to a region: possibly PO Boxes?
  # For now, drop
  tidylog::filter(!is.na(region)) %>% 
  # For now, drop if herd state doesn't match zip code state
  tidylog::filter(herd_state == abb) %>% 
  select(-abb)

```

# RenF90 table {.tabset}

* Key: CG number prior and post re-naming, number of animals in each CG

## Import

```{r renf90, echo = TRUE}

# Key for CG names, number of animals
renf90 <-
  readr::read_table2(here::here("data/raw_data/import_regions/renf90.tables"),
                     skip = 2,
                     col_names = c("cg_old", "n_animals", "cg_new")) %>% 
  # 4 rows with all NAs except cg_new: parsing error?
  filter(!is.na(cg_old))

```

`r scales::comma(nrow(renf90))` rows in RenF90 table

## Validation

* Contemporary group "continuity": contemporary groups can only be "subset"/split across life stages. How many contemporary groups have data for more than one trait?

```{r, eval=FALSE}

renf90 %>% 
  group_by(cg_old) %>% 
  summarise(n_traits = n()) %>% 
  ungroup %>% 
  group_by(n_traits) %>% 
  summarise(n_CGs = n())
  
```

* Do any CGs have multiple "new" names?
    + I.e., resulting from splitting a CG

```{r, eval=FALSE}

renf90 %>% 
  group_by(cg_old) %>% 
  summarise(n_names = n_distinct(cg_new)) %>% 
  ungroup() %>% 
  group_by(n_names) %>% 
  summarise(n = n())

```

# Animal solutions & phenotypes {.tabset}

* Effects in solutions file:
    + 2 == Breeding value
    + 3 == Maternal
    + 4 == Permanent environment

## Import raw solutions

* Import weaning weight direct and maternal EBVs
* Reshape from long to wide
* Attach adjusted weaning weights from `growth_pheno`
* Remove rows with no recorded weaning weight

```{r animal_solutions, echo = TRUE}
animal_solutions <-
  # File of WW EBVs parsed from BLUPF90 solutions file
  read_table2(here::here("data/raw_data/import_regions/ww_animal.txt"),
              col_names = c("trait", "effect", "id_new", "solution")) %>%
  mutate(effect = case_when(effect == 2 ~ "bv_sol",
                            effect == 3 ~ "mat_sol"),
         trait = "ww") %>%
  # Go from long to wide: expand `solution` column into `bv_sol` and `mat_sol` columns 
  tidyr::pivot_wider(names_from = effect,
                     values_from = solution) %>%
  # Join by trait and id_new
  # cols: id_new, bv_sol, mat_sol, weight, cg_new
  left_join(growth_pheno) %>% 
  # Remove if no weight recorded
  filter(!is.na(weight)) %>% 
  # Columns: id_new, cg_new, trait, bv_sol, mat_sol, weight
  select(id_new, cg_new, everything())
```

## Join

* Use `slice_cg_new` function to match up renamed CG IDs to the original CG IDs in `growth_zip`
* Append geographic information found in `growth_zip` to `animal_solutions` (joining by `cg_new` found in previous step)

```{r animal_regions_join}
animal_regions <-
  growth_zip %>%
  # Purpose: match up old CG name to blupf90 renamed CG
  # Slice second occurence because ww is trait 2
  slice_cg_new(trait_var = "ww", trait_order = 2) %>%
  # Purpose: add solutions from BLUPF90 output, add new IDs
  # join by cg_new, trait
  left_join(animal_solutions) %>%
  # Purpose: add et status, real registration number, sire and dam registration numbers 
  left_join(ped %>%
              select(id_new, full_reg, sire_reg, dam_reg, et_status))
```

## Filter and QC

* Remove region 8 but no fescue
* Remove ET calves
* Remove records pre-1990
* Remove region 4, region 6
* Remove creep-fed calves
* Remove if unknown parentage
* Remove single sire and single dam contemporary groups
* Remove contemporary groups with fewer than 5 animals
* Convert `weight`, `bv_sol`, `mat_sol` from lbs to kg

```{r animal_regions_filter}
animal_regions %<>%
  # Remove if assigned to region 8 but not in actual fescue belt
  mutate(helper = case_when(herd_state %in% c("CA",
                                              "WA",
                                              "OR",
                                              "PA",
                                              "NY",
                                              "WI",
                                              "NJ",
                                              "MA",
                                              "MD",
                                              "DE",
                                              "MI",
                                              "CT",
                                              "RI",
                                              "NH",
                                              "NE") & region == 8 ~ "drop",
                            TRUE ~ "keep")) %>%
  filter(helper == "keep") %>%
  # Remove ET calves
  filter(et_status == FALSE) %>%
  # Remove records prior to 1990
  mutate(year = lubridate::year(weigh_date)) %>% 
  filter(year >= 1990) %>% 
  # Remove region 4, 6
  filter(!region %in% c(4, 6)) %>%
  # Remove if unknown parentage
  filter_at(vars("sire_reg", "dam_reg"),
            all_vars(. != "0")) %>% 
  # Append creep codes
  left_join(read_csv(here::here("data/raw_data/import_regions/creep_codes_012621.csv"),
                     skip = 1,
                     col_names = c("full_reg", "creep"))) %>% 
  # Remove single sire, single dam CG groups
  group_by(cg_new) %>% 
  filter(n_distinct(sire_reg) > 1) %>% 
  filter(n_distinct(dam_reg) > 1) %>%
  # Fill in creep codes by contemporary group
  tidyr::fill(creep, .direction = "downup") %>% 
  # n animals per CG
  mutate(n_animals = n()) %>% 
  ungroup() %>%
  # Remove if creep fed or unknown
  filter(creep == 1) %>% 
  # Remove CGs with fewer than 5 animals
  filter(n_animals >= 5) %>% 
  select(-helper, -et_status, -creep) %>% 
  # Convert weight to kg
  mutate_at(vars("weight", "bv_sol", "mat_sol"),
            ~ measurements::conv_unit(.,
                                      from = "lbs",
                                      to = "kg"))

```

> List of contemporary groups containing phenotypic outliers after filtering

```{r outlier_cg}
outlier_cg <-
  animal_regions %>% 
  # KEEPING only outliers in order to generate a list of black-listed contemporary group numbers
  mutate(outlier_min = mean(weight) - (sd(weight) * 3),
         outlier_max = mean(weight) + (sd(weight) * 3)) %>%
  ungroup() %>%
  mutate(outlier_drop = case_when(outlier_min > weight ~ TRUE,
                                  weight > outlier_max ~ TRUE,
                                  TRUE ~ FALSE)) %>%
  filter(outlier_drop == TRUE) %>%
  distinct(cg_new)
  
```

* Remove contemporary groups containing phenotypic outliers

```{r remove_outliers}
animal_regions %<>%
  filter(!cg_new %in% outlier_cg$cg_new) %>% 
  select(id_new, full_reg, sire_reg, dam_reg, cg_new, n_animals, region, desc, herd_state, zip, lat, lng, weigh_date, year, weight, bv_sol, mat_sol)
```

## Export

```{r export_animal}
animal_regions %>% 
  write_rds(here::here("data/derived_data/import_regions/animal_regions.rds"))
```

# Contemporary group solutions

## Import raw solutions

```{r cg_solutions}
cg_solutions <-
  read_table2(here::here("data/raw_data/cg_sol.txt"),
              col_names = c("trait", "effect", "cg_new", "solution")) %>%
  # don't need birth weight or pwg
  filter(trait == 2) %>% 
  mutate(trait = "ww") %>% 
  select(-effect)
```

## Join

* Keep on contemporary groups in post-filtering `animal_regions`
* Convert `cg_sol` from lbs to kg

```{r cg_regions}
cg_regions <-
  animal_regions %>% 
  distinct(cg_new, n_animals, region, desc, herd_state, zip, lat, lng, weigh_date, year) %>% 
  left_join(cg_solutions %>% 
              select(cg_new, cg_sol = solution)) %>% 
  mutate(cg_sol = measurements::conv_unit(cg_sol, from = "lbs", to = "kg"))
```

## Export

```{r export_cg}
cg_regions %>% 
  write_rds(here::here("data/derived_data/import_regions/cg_regions.rds"))

```

# Key of region orgins (regardless of if WW record available)

```{r reg_region, eval = FALSE}

reg_region <-
  purrr::pmap_dfr(list(x = c("Birth", "Wean", "Year"),
                       y = c("bw", "ww", "pwg"),
                       z = c(1, 2, 3),
                       # CG column 
                       cg = list("X4", "X5", "X6")),
            .f = function(x, y, z, cg) {
              
              # File of zip codes corresponding to trait CGs prior to re-naming
              read_table2(here::here(glue("data/raw_data/import_regions/{x}_CG_ZIP.txt")),
                          skip = 1,
                          col_names = c("cg_old", "zip_raw", "herd_state")) %>% 
                # Foreign zips, drop
                filter(!str_detect(zip_raw, "[[:alpha:]]")) %>% 
                # Strip down to five digit zip code
                # DON'T convert from character to numeric: removes leading zeros
                mutate(zip = case_when(str_detect(zip_raw, "[[:punct:]]") ~ str_extract(zip_raw, "^[[:digit:]]{5}"),
                                       TRUE ~ zip_raw),
                       trait = y) %>% 
                # Append region data
                left_join(region_key) %>% 
                # Append re-named CG
                slice_cg_new(trait_var = y,
                             trait_order = z) %>% 
                # Append re-named animal IDs by matching to re-named CG
                left_join(readr::read_table2(here::here("data/raw_data/import_regions/renf90.dat"),
                                             col_names = FALSE) %>%
                            select(cg_new := !!rlang::sym(cg), id_new = X7) %>% 
                            filter(cg_new != "0")) %>% 
                left_join(ped %>% 
                            select(id_new, full_reg)) %>% 
                select(full_reg, region, desc, herd_state, zip, lat, lng)
            }) %>% 
  distinct(full_reg, region, desc, herd_state, zip, lat, lng)

```

```{r export_reg_region, eval=FALSE}
reg_region %>% 
  write_rds(here::here("data/derived_data/import_regions/reg_region.rds"))
```

# Commentary

```{r}
animal_regions %>% 
  group_by(region) %>% 
  summarise(n = n(),
            n_cg = n_distinct(cg_new))
```

```{r}
cg_regions %>% 
  group_by(region) %>% 
  summarise(n = sum(n_animals),
            n_cg = n())
```
